// =============================================================================
// Copyright 2006-2010 Daniel W. Dyer
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// =============================================================================
package org.processmining.plugins.joosbuijs.processtrees.geneticminer;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import org.processmining.plugins.boudewijn.tree.Node;
import org.processmining.plugins.boudewijn.tree.Tree;
import org.uncommons.maths.random.Probability;
import org.uncommons.watchmaker.framework.operators.AbstractCrossover;

/**
 * Cross-over operator for the trees of {@link Node}s.
 * 
 * @author jbuijs
 */
public class TreeCrossover extends AbstractCrossover<Tree> {
	private final Probability crossoverProbability;

	public TreeCrossover(Probability crossoverProbability) {
		super(1);
		this.crossoverProbability = crossoverProbability;
	}

	/**
	 * Swaps randomly selected sub-trees between the two parents.
	 * 
	 * @param parent1
	 *            The first parent.
	 * @param parent2
	 *            The second parent.
	 * @param numberOfCrossoverPoints
	 *            The number of cross-overs to perform.
	 * @param rng
	 *            A source of randomness.
	 * @return A list of two offspring, generated by swapping sub-trees between
	 *         the two parents.
	 */
	@Override
	protected List<Tree> mate(Tree tree1, Tree tree2, int numberOfCrossoverPoints, Random rng) {
		//Initialize the offspring by DEEP copying the two parents into the offspring 
		List<Tree> offspring = new ArrayList<Tree>(2);
		Tree offspring1 = new Tree(tree1);
		Tree offspring2 = new Tree(tree2);

		//If we should apply crossover then modify this list
		if (crossoverProbability.nextEvent(rng)) {
			offspring1.resetFitness();
			offspring2.resetFitness();
			
			//Now apply crossover as many times as required
			for (int i = 0; i < numberOfCrossoverPoints; i++) {
				//Find a single crossover-point in both trees so crossover is ~homologous
				//Note that we repeatedly apply crossover on the same OFFSPRING (if numberOfCrossoverPoints > 1)
				//int crossoverPoint = rng.nextInt(Math.min(offspring1.countNodes(), offspring2.countNodes()));
				//Node subTree1 = offspring1.getNode(crossoverPoint);
				//Node subTree2 = offspring2.getNode(crossoverPoint);
				Node subTree1 = offspring1.getRandomNode(rng);
				Node subTree2 = offspring2.getRandomNode(rng);

				//Get the parents
				Node parentOfSubtree1 = subTree1.getParent();
				Node parentOfSubtree2 = subTree2.getParent();

				//ROOT alert
				if (parentOfSubtree1 == null) {
					//Okay, tell offspring1 that the root is now subtree2
					offspring1.setRoot(subTree2);
				} else {
					//Now replace children
					parentOfSubtree1.replaceChild(subTree1, subTree2);
				}

				if (parentOfSubtree2 == null) {
					//Okay, tell offspring2 that the root is now subtree1
					offspring2.setRoot(subTree1);
				} else {
					//FIXME test if this works, tree is temporarely inconsistent 
					parentOfSubtree2.replaceChild(subTree2, subTree1);
				}

				//Make sure the parents are correctly set
				subTree2.setParent(parentOfSubtree1);
				subTree1.setParent(parentOfSubtree2);
			}

			offspring.add(offspring1);
			offspring.add(offspring2);
		} else {
			//ALWAYS return 2 nodes!!! (otherwise population decreases!!!)
			offspring.add(offspring1);
			offspring.add(offspring2);
		}

		//Perform a tree test
		for (Tree tree : offspring) {
			assert tree.checkTree();
		}

		return offspring;
	}
}
