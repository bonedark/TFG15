// =============================================================================
// Copyright 2006-2010 Daniel W. Dyer
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// =============================================================================
package org.processmining.plugins.joosbuijs.blockminer.genetic.conformancefitness;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import org.uncommons.maths.random.Probability;
import org.uncommons.watchmaker.framework.operators.AbstractCrossover;

/**
 * Cross-over operator for the trees of {@link Node}s.
 * 
 * @author jbuijs
 * @author Daniel Dyer (original)
 */
public class TreeCrossover extends AbstractCrossover<Tree> {
	private final Probability crossoverProbability;

	/**
	 * Creates a single-point cross-over operator.
	 */
	public TreeCrossover() {
		//Always apply crossover
		this(new Probability(1.0d));
	}

	public TreeCrossover(Probability crossoverProbability) {
		super(1);
		this.crossoverProbability = crossoverProbability;
	}

	/**
	 * Swaps randomly selected sub-trees between the two parents.
	 * 
	 * @param parent1
	 *            The first parent.
	 * @param parent2
	 *            The second parent.
	 * @param numberOfCrossoverPoints
	 *            The number of cross-overs to perform.
	 * @param rng
	 *            A source of randomness.
	 * @return A list of two offspring, generated by swapping sub-trees between
	 *         the two parents.
	 */
	@Override
	protected List<Tree> mate(Tree tree1, Tree tree2, int numberOfCrossoverPoints, Random rng) {
		//Initialize offspring list by adding parent nodes
		List<Tree> offspring = new ArrayList<Tree>(2);
		Tree offspring1 = tree1;
		Tree offspring2 = tree2;

		//If we should apply crossover then modify this list
		if (crossoverProbability.nextEvent(rng)) {

			for (int i = 0; i < numberOfCrossoverPoints; i++) {
				int crossoverPoint = rng.nextInt(Math.min(tree1.countNodes(),tree2.countNodes()));
				Node subTree1 = tree1.getNode(crossoverPoint);
				//int crossoverPoint2 = rng.nextInt(parent2.countNodes());
				Node subTree2 = tree2.getNode(crossoverPoint);

				//Only copy the structure of the subtree, replace leafs with originals (order)
				//TODO finish
				//List<EventClassNode> tree1Classes = subTree1.getLeafs();
				//List<EventClassNode> tree2Classes = subTree2.getLeafs();

				offspring1 = new Tree(tree1);
				offspring1.replaceNode(crossoverPoint, subTree2);
				offspring2 = new Tree(tree2);
				offspring2.replaceNode(crossoverPoint, subTree1);
			}

			offspring.add(offspring1);
			offspring.add(offspring2);
		} else {
			//ALWAYS return 4 nodes!!! (otherwise population decreases!!!)
			offspring.add(offspring1);
			offspring.add(offspring2);
		}
		return offspring;
	}
}
